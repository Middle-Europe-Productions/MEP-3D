

#include "transfer_function.hpp"

#include <MEP-3D/mep-3d.hpp>

#include <glog/logging.h>
#include <imgui.h>
#include <stb_image.h>
#include <MEP-3D/template/scene_ui_layer_handler_context.hpp>
#include <algorithm>
#include <cstdint>

#include "common.hpp"
#include "point_canvas.hpp"

namespace {

constexpr uint8_t kParaviewCoolWarm[] = {
    0x89, 0x50, 0x4e, 0x47, 0xd,  0xa,  0x1a, 0xa,  0x0,  0x0,  0x0,  0xd,
    0x49, 0x48, 0x44, 0x52, 0x0,  0x0,  0x0,  0xb4, 0x0,  0x0,  0x0,  0x1,
    0x8,  0x6,  0x0,  0x0,  0x0,  0x77, 0xca, 0x84, 0xf4, 0x0,  0x0,  0x1,
    0x7a, 0x49, 0x44, 0x41, 0x54, 0x78, 0x5e, 0x63, 0xb4, 0xf6, 0x39, 0xf0,
    0x9f, 0x91, 0x89, 0x89, 0x81, 0x91, 0x89, 0x91, 0x81, 0x99, 0x99, 0x99,
    0x1,  0xc4, 0x66, 0x2,  0xd3, 0x8,  0x3e, 0x48, 0xe,  0x24, 0xc6, 0x4,
    0x54, 0x83, 0x90, 0x63, 0x62, 0x40, 0xe8, 0x43, 0xd6, 0xf,  0xd2, 0x7,
    0xe4, 0x33, 0x32, 0x42, 0xcd, 0x64, 0x42, 0xd0, 0x8c, 0xc,  0x40, 0x3b,
    0x20, 0x7c, 0x46, 0x46, 0x90, 0x3a, 0x98, 0x1a, 0x20, 0xd,  0xe5, 0x83,
    0xec, 0x60, 0x4,  0xab, 0x43, 0x88, 0x21, 0xf8, 0xc,  0xc,  0x40, 0x27,
    0x30, 0x30, 0x31, 0x33, 0x82, 0x69, 0xa0, 0x33, 0x19, 0xc0, 0xe6, 0x30,
    0x31, 0x30, 0x80, 0xd4, 0x40, 0xe4, 0xa0, 0x6a, 0x98, 0x60, 0xf4, 0x7f,
    0xb0, 0x5a, 0xb0, 0x19, 0x60, 0x75, 0xff, 0x19, 0x80, 0xda, 0x81, 0xea,
    0x81, 0x34, 0x94, 0xf,  0x96, 0x63, 0xfc, 0xcf, 0xc0, 0xc0, 0xf0, 0xf,
    0x28, 0xf7, 0x9f, 0x1,  0xc2, 0xff, 0x7,  0xa6, 0x19, 0x19, 0xff, 0x43,
    0xc4, 0x18, 0x80, 0xe2, 0xc,  0x7f, 0x11, 0x72, 0x20, 0x3e, 0x23, 0xc8,
    0xec, 0x7f, 0xc,  0x4c, 0xc,  0x10, 0x9a, 0x11, 0x44, 0x33, 0xfc, 0x3,
    0x9b, 0xd,  0x67, 0x83, 0xe5, 0x80, 0xfa, 0xfe, 0x3,  0xd5, 0xfc, 0x7,
    0xd2, 0xc,  0x50, 0xfa, 0x3f, 0x50, 0x1d, 0x88, 0xfd, 0xf,  0x2a, 0x6,
    0xa6, 0x81, 0x62, 0xff, 0x20, 0x6a, 0x19, 0x19, 0x60, 0x6c, 0xa0, 0xdf,
    0xfe, 0xfd, 0x61, 0x0,  0x99, 0xc7, 0x8,  0x94, 0x63, 0x0,  0xe9, 0x3,
    0x9a, 0x5,  0x67, 0x83, 0xc4, 0xfe, 0x41, 0xd4, 0x32, 0x0,  0xcd, 0x3,
    0xcb, 0x43, 0xc5, 0x18, 0xc0, 0xea, 0x81, 0xfe, 0xfa, 0xfb, 0x7,  0x28,
    0x5,  0xa4, 0x81, 0xea, 0xc0, 0x62, 0xff, 0x40, 0x6c, 0xa0, 0x18, 0x88,
    0xfe, 0xfb, 0x97, 0xe1, 0x3f, 0xd0, 0x4c, 0x86, 0x7f, 0x10, 0x75, 0xff,
    0xff, 0x83, 0x68, 0xa0, 0x18, 0x48, 0x2d, 0x48, 0xe,  0x24, 0xe,  0x94,
    0xff, 0xff, 0x7,  0xa4, 0xee, 0x3f, 0x3,  0x88, 0x6,  0xd9, 0xf1, 0xf,
    0xc8, 0x7,  0x6a, 0x4,  0x32, 0xff, 0x81, 0xc5, 0xfe, 0x3,  0xd5, 0xfd,
    0xff, 0xb,  0xd1, 0x7,  0x92, 0x3,  0xf3, 0x51, 0xc4, 0xfe, 0x41, 0xd4,
    0xfe, 0xfd, 0xf,  0xa1, 0x81, 0x72, 0x20, 0x75, 0xff, 0x80, 0x7c, 0x98,
    0xfa, 0x7f, 0x7f, 0x80, 0x6a, 0xfe, 0x82, 0xd4, 0xfd, 0x67, 0x0,  0xb1,
    0xff, 0x1,  0xd9, 0xff, 0x7e, 0xff, 0x63, 0xf8, 0x7,  0x52, 0xfb, 0xfb,
    0x2f, 0x3,  0x48, 0xed, 0x7f, 0xa0, 0xfa, 0xbf, 0xbf, 0x40, 0xea, 0xfe,
    0x33, 0xfc, 0xfd, 0x9,  0x14, 0xfb, 0x3,  0xa4, 0xbf, 0x3,  0xf9, 0xbf,
    0x80, 0x7a, 0x7e, 0xfe, 0x67, 0x0,  0x0,  0x27, 0xf7, 0xf2, 0xdf, 0xa6,
    0x6f, 0xf8, 0x80, 0x0,  0x0,  0x0,  0x0,  0x49, 0x45, 0x4e, 0x44, 0xae,
    0x42, 0x60, 0x82};

constexpr uint8_t kRainbow[] = {
    0x89, 0x50, 0x4e, 0x47, 0xd,  0xa,  0x1a, 0xa,  0x0,  0x0,  0x0,  0xd,
    0x49, 0x48, 0x44, 0x52, 0x0,  0x0,  0x0,  0xb4, 0x0,  0x0,  0x0,  0x1,
    0x8,  0x6,  0x0,  0x0,  0x0,  0x77, 0xca, 0x84, 0xf4, 0x0,  0x0,  0x0,
    0x46, 0x49, 0x44, 0x41, 0x54, 0x78, 0x5e, 0x63, 0x64, 0x60, 0xf8, 0xff,
    0x9f, 0x81, 0x85, 0x81, 0x1,  0x8c, 0x39, 0x70, 0xd0, 0x20, 0xf9, 0xc1,
    0x24, 0xc7, 0xfe, 0x1f, 0xe8, 0xd0, 0x3f, 0x40, 0xfc, 0x3,  0x8d, 0xc6,
    0x26, 0x6,  0x53, 0x33, 0xb0, 0x72, 0x4c, 0xc,  0xff, 0x18, 0xd0, 0x83,
    0x70, 0xb0, 0x5,  0x2b, 0xba, 0xfb, 0x18, 0x7f, 0x42, 0x83, 0x77, 0xf0,
    0x6,  0x2b, 0x3,  0x3,  0xb2, 0xdb, 0xfe, 0x30, 0x30, 0x0,  0x0,  0x85,
    0x9e, 0x5d, 0x0,  0x63, 0x5b, 0x7,  0x6f, 0x0,  0x0,  0x0,  0x0,  0x49,
    0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82};
constexpr uint8_t kIceFire[] = {
    0x89, 0x50, 0x4e, 0x47, 0xd,  0xa,  0x1a, 0xa,  0x0,  0x0,  0x0,  0xd,
    0x49, 0x48, 0x44, 0x52, 0x0,  0x0,  0x0,  0xb4, 0x0,  0x0,  0x0,  0x1,
    0x8,  0x6,  0x0,  0x0,  0x0,  0x77, 0xca, 0x84, 0xf4, 0x0,  0x0,  0x1,
    0xca, 0x49, 0x44, 0x41, 0x54, 0x78, 0x5e, 0x63, 0x64, 0x60, 0x60, 0xf8,
    0xcf, 0xc4, 0xcc, 0xc1, 0xc0, 0xcc, 0xc4, 0xce, 0xc0, 0xc2, 0xca, 0xc9,
    0xc0, 0xc4, 0xcc, 0xc2, 0xc0, 0xc4, 0xc2, 0xc9, 0x0,  0x24, 0x18, 0xfe,
    0x33, 0x73, 0x32, 0xfc, 0x67, 0x64, 0x61, 0xf8, 0xc7, 0xc4, 0xca, 0xf0,
    0x17, 0xc8, 0xfe, 0xb,  0x64, 0x83, 0x68, 0xa0, 0x22, 0x6,  0x6,  0x66,
    0x76, 0x6,  0x6,  0x46, 0x66, 0xb0, 0x3a, 0x38, 0x1b, 0x68, 0xe,  0x5c,
    0x8e, 0x89, 0x5,  0x28, 0xf,  0x32, 0x8b, 0x85, 0x81, 0x91, 0x89, 0x9,
    0x68, 0x1c, 0x90, 0xcf, 0xc4, 0xc,  0xa6, 0x41, 0x7c, 0xb0, 0x18, 0x2b,
    0x48, 0x8e, 0x99, 0x81, 0x91, 0x5,  0xa2, 0x86, 0x85, 0x15, 0xa8, 0x8e,
    0x89, 0x11, 0xa8, 0x9e, 0x91, 0x81, 0x19, 0xc8, 0x66, 0x4,  0xb2, 0x99,
    0xd0, 0x68, 0x6,  0x66, 0x46, 0x6,  0x74, 0x31, 0x66, 0x56, 0x66, 0xb0,
    0x1e, 0x90, 0x7a, 0x46, 0x90, 0x7a, 0x90, 0x1a, 0x16, 0xa0, 0x18, 0x90,
    0x6,  0xf1, 0x99, 0x41, 0xe6, 0x0,  0xdd, 0xc0, 0xa,  0x94, 0x3,  0xb1,
    0x59, 0x80, 0x72, 0x4c, 0x40, 0x39, 0x10, 0xcd, 0xc,  0x52, 0xb,  0x94,
    0x83, 0xd9, 0xcd, 0xe,  0x94, 0x63, 0x5,  0xaa, 0xe7, 0x62, 0x66, 0x62,
    0x0,  0xd1, 0xac, 0x8c, 0x8c, 0xc,  0x9c, 0x2c, 0x4c, 0xc,  0x2c, 0x40,
    0x9a, 0x3,  0x44, 0x3,  0xe5, 0x38, 0x80, 0x72, 0x2c, 0x40, 0x1a, 0x84,
    0xb9, 0x19, 0xfe, 0x0,  0xe5, 0xfe, 0x31, 0x70, 0x81, 0x68, 0x86, 0x7f,
    0xc,  0x9c, 0x8c, 0x7f, 0x19, 0x80, 0x21, 0xc6, 0xc0, 0xca, 0xf8, 0x8f,
    0x81, 0x3,  0x28, 0xc6, 0xc,  0xa6, 0xff, 0x82, 0xd5, 0x30, 0xff, 0xfd,
    0xc2, 0xc0, 0xf4, 0xff, 0x17, 0x3,  0xf3, 0xdf, 0xaf, 0xc,  0x8c, 0x40,
    0x1a, 0x84, 0x99, 0x80, 0x62, 0x8c, 0xff, 0x7f, 0x33, 0x30, 0xfd, 0xfb,
    0x2,  0x11, 0xfb, 0xb,  0xa1, 0xff, 0xff, 0xfb, 0xc5, 0xf0, 0xff, 0xf7,
    0x37, 0x86, 0xff, 0xff, 0x7e, 0x3,  0xe9, 0xaf, 0xc,  0x10, 0x3e, 0x94,
    0xfe, 0xf7, 0x13, 0x28, 0xf6, 0x11, 0x28, 0xf6, 0x9d, 0xe1, 0xdf, 0xef,
    0xc7, 0xc,  0xff, 0xff, 0x32, 0x0,  0x69, 0x60, 0x4c, 0x2,  0x69, 0x30,
    0xfb, 0x17, 0x84, 0xd,  0xd4, 0xca, 0x80, 0xcc, 0x87, 0xb1, 0xff, 0xfd,
    0x3,  0xaa, 0x7,  0xaa, 0x1,  0xf1, 0xff, 0xfe, 0x66, 0x0,  0xab, 0x1,
    0xb3, 0xa1, 0x62, 0x40, 0xab, 0x19, 0xfe, 0x41, 0xcd, 0x4,  0xd3, 0x40,
    0x36, 0x48, 0x1d, 0x88, 0xfd, 0x17, 0xa8, 0x6,  0x99, 0xfe, 0xff, 0x87,
    0x91, 0xe1, 0xcf, 0x4f, 0xa0, 0x19, 0x7f, 0x18, 0x18, 0x7e, 0x81, 0xf4,
    0x0,  0xcd, 0xfe, 0x5,  0x14, 0x3,  0xd9, 0xf1, 0x17, 0xc8, 0xfe, 0xd,
    0x14, 0xff, 0xfb, 0xf7, 0x3f, 0xc3, 0x6f, 0xa0, 0x3d, 0x7f, 0x81, 0xf2,
    0xbf, 0x7f, 0xff, 0x67, 0x0,  0xc9, 0x1,  0x85, 0x19, 0x7e, 0x32, 0x30,
    0x32, 0x0,  0x85, 0x80, 0x34, 0x3,  0xa,  0xd,  0x92, 0x83, 0x7a, 0x1,
    0x28, 0xf7, 0x9f, 0xe1, 0xf,  0x13, 0x3,  0xc3, 0x77, 0x60, 0x52, 0x3,
    0xd1, 0x40, 0xa3, 0x19, 0xbe, 0x3,  0x53, 0x2d, 0x58, 0x3f, 0xd0, 0xfc,
    0x3f, 0xff, 0x19, 0x18, 0xbe, 0x1,  0xd,  0xf9, 0x9,  0xa2, 0xff, 0x33,
    0x30, 0x0,  0x0,  0x38, 0x16, 0xbe, 0x6,  0xd6, 0xb8, 0x3f, 0x4,  0x0,
    0x0,  0x0,  0x0,  0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82};
constexpr uint8_t kBlackBody[] = {
    0x89, 0x50, 0x4e, 0x47, 0xd,  0xa,  0x1a, 0xa,  0x0,  0x0,  0x0,  0xd,
    0x49, 0x48, 0x44, 0x52, 0x0,  0x0,  0x0,  0xb4, 0x0,  0x0,  0x0,  0x1,
    0x8,  0x6,  0x0,  0x0,  0x0,  0x77, 0xca, 0x84, 0xf4, 0x0,  0x0,  0x0,
    0x52, 0x49, 0x44, 0x41, 0x54, 0x78, 0x5e, 0x63, 0x64, 0x60, 0x60, 0xf8,
    0xcf, 0x4,  0x24, 0x98, 0x81, 0x98, 0x5,  0x88, 0x41, 0x6c, 0x56, 0x34,
    0x1a, 0x59, 0x8c, 0x5,  0x4d, 0x2d, 0xad, 0xf5, 0xc1, 0xdc, 0x2,  0xb3,
    0x97, 0x9,  0xea, 0x4e, 0x6c, 0xf6, 0x62, 0x73, 0x3b, 0x35, 0xf4, 0x31,
    0xa0, 0x3b, 0x2,  0x16, 0x50, 0xe4, 0x7a, 0x1e, 0x66, 0x1e, 0xb9, 0xe,
    0x1e, 0x4c, 0x91, 0x5,  0xc,  0x1c, 0x46, 0x46, 0x2e, 0x6,  0x46, 0x46,
    0x56, 0x6,  0x10, 0xcd, 0x80, 0xc4, 0x67, 0x18, 0x0,  0x39, 0x0,  0x2d,
    0x1e, 0x3,  0xfe, 0x6b, 0x89, 0x1e, 0x5e, 0x0,  0x0,  0x0,  0x0,  0x49,
    0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82};

constexpr char kTransferFunction[] = "transfer_function";

class TransferFunctionController : public mep::UI_HANDLER_BASE(SceneUILayer),
                                   public mep::Identity,
                                   public mep::ILCClient {
 public:
  TransferFunctionController()
      : mep::Identity(kTransferFunction, kTransferFunction) {
    LOG(INFO) << __func__;
  }

  std::size_t NumberOfTf() { return color_maps_.size(); }

  void LoadFromMemory(const uint8_t* data,
                      std::size_t size,
                      const std::string& name) {
    int w, h, n;
    uint8_t* img_data = stbi_load_from_memory(data, size, &w, &h, &n, 4);
    auto img = std::vector<uint8_t>(img_data, img_data + w * 1 * 4);
    stbi_image_free(img_data);
    auto image = mep::Image(name.c_str());
    image.LoadFromMemory(img, {(int)img.size() / 4, 1}, mep::Image::Type::RGBA);
    color_maps_.emplace_back(std::move(image));
  }

  void DrawSelectable() {
    if (selected_color_map_ == -1) {
      return;
    }
    if (ImGui::BeginCombo("Colormap",
                          color_maps_[selected_color_map_].GetName().c_str())) {
      for (size_t i = 0; i < color_maps_.size(); ++i) {
        if (ImGui::Selectable(color_maps_[i].GetName().c_str(),
                              selected_color_map_ == i)) {
          selected_color_map_ = i;
          UpdateColorMap();
        }
      }
      ImGui::EndCombo();
    }
  }
  void DrawImage() {
    handler_.Use();
    ImVec2 canvas_size = ImGui::GetContentRegionAvail();
    ImGui::Image(reinterpret_cast<void*>(handler_.GetHandler()),
                 ImVec2(canvas_size.x, 100));

    canvas_size.y -= 20;
  }

  void DrawCanvas() {
    if (canvas_.DrawAndNotify()) {
      UpdateColorMap();
    }
    if (ImGui::Button("Reset Points")) {
      VLOG(3) << "Reseting canvas points";
      canvas_.Reset();
      UpdateColorMap();
    }
  }
  std::vector<mep::Point>::const_iterator MoveToNextAval(
      std::vector<mep::Point>::const_iterator iter) {
    do {
      iter++;
    } while (!iter->status);
    return iter;
  }

  void UpdateColorMap() {
    auto points_it = canvas_.GetPoints().begin();
    auto& image = color_maps_[selected_color_map_];
    std::size_t pixels_count = image.GetSize().x_;
    DCHECK(canvas_.GetPoints().size() >= 2);
    for (std::size_t i = 0; i < pixels_count; i++) {
      float x = static_cast<float>(i) / pixels_count;
      auto points_it_upper = MoveToNextAval(points_it);
      if (x > points_it_upper->position.x_) {
        points_it = MoveToNextAval(points_it);
        points_it_upper = points_it;
        points_it_upper = MoveToNextAval(points_it_upper);
      }
      float alpha_value =
          points_it->position.y_ +
          (points_it_upper->position.y_ - points_it->position.y_) /
              (points_it_upper->position.x_ - points_it->position.x_) *
              (x - points_it->position.x_);
      image[{(int)i * 4 + 3, 0}] = static_cast<Uint8>(alpha_value * 255.f);
    }
    ChangeImage(selected_color_map_);
  }

  void ChangeImage(std::size_t selected_image) {
    DCHECK(selected_image < color_maps_.size());
    handler_.Update(color_maps_[selected_image]);
  }
  virtual void OnReceive(const mep::IdentityView& id,
                         const nlohmann::json& message) {
    LOG(INFO) << "Received message " << id.ToString() << ", " << message;
  }
  virtual void OnConnectionClosed() { LOG(INFO) << "Closing connection"; }
  virtual void OnConnectionOppened() {
    nlohmann::json message;
    message[vr::kTextureNode] = handler_.GetHandler();
    message[vr::kTextureAction] = vr::kTextureCreate;
    connector_->Send(std::make_unique<mep::ILCPackage>(
        *this,
        mep::IdentityView(std::nullopt, vr::kVolumeRenderer, std::nullopt),
        message));
  }
  void SetUp(mep::Scene* scene) override {
    LoadFromMemory(kParaviewCoolWarm, sizeof(kParaviewCoolWarm),
                   "Paraview Cool Warm");
    LoadFromMemory(kIceFire, sizeof(kIceFire), "Ice Fire");
    LoadFromMemory(kRainbow, sizeof(kRainbow), "Rainbow");
    LoadFromMemory(kBlackBody, sizeof(kBlackBody), "Black Body");
    handler_.Create();
    selected_color_map_ = 0;
    UpdateColorMap();
    connector_ = std::make_unique<mep::ILCConnector>(*this);
    if (!connector_->Connect(this)) {
      LOG(ERROR) << "Unable to connect to ILC";
    }
  }

 private:
  std::unique_ptr<mep::ILCConnector> connector_;
  std::size_t selected_color_map_;
  std::vector<mep::Image> color_maps_;
  std::vector<ImVec2> alpha_points_;
  mep::Texture handler_;
  mep::PointCanvas canvas_;
};

}  // namespace

namespace mep {
UI_HANDLER_D(tf::VolumeRenderingHandlers,
             TransferFunction,
             SceneUILayer,
             TransferFunctionController) {
  ImGui::Text("Transfer Function");
  DrawSelectable();
  DrawImage();
  DrawCanvas();
}
}  // namespace mep

namespace tf {
void Register() {
  ADD_UI_ELEMENT(VolumeRenderingHandlers::TransferFunction,
                 "transfer_function");
}
}  // namespace tf
